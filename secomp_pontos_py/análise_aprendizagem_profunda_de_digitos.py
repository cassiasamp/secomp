# -*- coding: utf-8 -*-
"""Análise aprendizagem profunda de digitos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EGVpsDUmKjSmrtZcHzWysDzdeEhGbHRK
"""

import tensorflow
from tensorflow import keras

"""## Carregamento dos dados"""

mnist = keras.datasets.mnist

mnist

(imagens_treino, identificacoes_treino), (imagens_teste, identificacoes_teste) = mnist.load_data()

"""## Entendendo os dados"""

imagens_treino[0]

import matplotlib.pyplot as plt 

plt.gray() 
plt.matshow(imagens_treino[0]) 
plt.show()

imagens_treino.shape

len(identificacoes_treino)

identificacoes_treino

identificacoes_treino[0]

"""## Fazendo a rede"""

modelo_inicial = keras.models.Sequential([
  keras.layers.Flatten(input_shape=(28, 28)),
  keras.layers.Dense(512, activation=tf.nn.relu),
  keras.layers.Dense(10, activation=tf.nn.softmax)
])

modelo_inicial.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

modelo_inicial.fit(imagens_treino, identificacoes_treino, epochs=5)

print('Métrica inicial')
modelo_inicial.evaluate(imagens_teste, identificacoes_teste)

"""## Normaliza"""

# normalizacao
imagens_treino_norm, imagens_teste_norm = imagens_treino / 255.0, imagens_teste / 255.0

modelo_norm = keras.models.Sequential([
  keras.layers.Flatten(input_shape=(28, 28)),
  keras.layers.Dense(512, activation=tf.nn.relu),
  keras.layers.Dense(10, activation=tf.nn.softmax)
])

modelo_norm.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

modelo_norm.fit(imagens_treino_norm, identificacoes_treino, epochs=5)

#perda e acuracia
print("Métrica com normalização")
modelo_norm.evaluate(imagens_teste_norm, identificacoes_teste)

"""## Adiciona dropout"""

modelo_drop = keras.models.Sequential([
  keras.layers.Flatten(input_shape=(28, 28)),
  keras.layers.Dense(512, activation=tf.nn.relu),
  keras.layers.Dropout(0.2),
  keras.layers.Dense(10, activation=tf.nn.softmax)
])

modelo_drop.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

modelo_drop.fit(imagens_treino, identificacoes_treino, epochs=5)

print('Métrica com normalização e dropout')
modelo_drop.evaluate(imagens_teste, identificacoes_teste)

"""## Normalizacao + dropout"""

modelo_norm_drop = keras.models.Sequential([
  keras.layers.Flatten(input_shape=(28, 28)),
  keras.layers.Dense(512, activation=tf.nn.relu),
  keras.layers.Dropout(0.2),
  keras.layers.Dense(10, activation=tf.nn.softmax)
])

modelo_norm_drop.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

modelo_norm_drop.fit(imagens_treino_norm, identificacoes_treino, epochs=5)

print('Métrica com normalização e dropout')
modelo_norm_drop.evaluate(imagens_teste_norm, identificacoes_teste)

"""## Salva modelo"""

modelo_norm_drop.save('modelo_norm_drop_digitos.h5')

from tensorflow.keras.models import load_model

modelo_norm_drop_salvo = load_model('modelo_norm_drop_digitos.h5')

import numpy as np

resultado_modelo_norm_drop = modelo_norm_drop.predict(imagens_teste)
print('resultado teste modelo salvo:', np.argmax(resultado_modelo_norm_drop[1]))
print('número da imagem de teste:', identificacoes_teste[1])